/**
 * SISTEMA COOPERATIVA FAMILIAR - VERSÃO GITHUB ESTÁVEL
 * * Este código realiza duas funções principais:
 * 1. REGISTRO DE DADOS: Salva cada entrega em uma linha nova na primeira aba (Histórico).
 * 2. ORGANIZAÇÃO DE DADOS: Soma as quantidades automaticamente na aba "ORGANIZAÇÃO_DE_DADOS",
 * evitando duplicar nomes de produtores e somando valores na mesma célula.
 */

function doPost(e) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  // Aba 1: Onde ficam os registros individuais (Histórico)
  const sheetHistorico = ss.getSheets()[0]; 
  
  // Nome da aba para consolidação (Soma Mensal)
  const NOME_ABA_CONSOLIDADO = "ORGANIZAÇÃO_DE_DADOS";
  
  // Localiza ou cria a aba de organização caso não exista
  let sheetConsolidado = ss.getSheetByName(NOME_ABA_CONSOLIDADO);
  if (!sheetConsolidado) {
    sheetConsolidado = ss.insertSheet(NOME_ABA_CONSOLIDADO);
  }

  const data = e.parameter;

  // Padronização: Nome do produtor sempre em MAIÚSCULAS
  if (data.nome) {
    data.nome = data.nome.toUpperCase();
  }
  
  // LockService impede que envios simultâneos causem erros de escrita na planilha
  const lock = LockService.getScriptLock();
  
  try {
    // Aguarda até 30 segundos para obter acesso exclusivo à planilha
    lock.waitLock(30000);

    // --- PARTE 1: GRAVAÇÃO NO HISTÓRICO (RECEBIMENTO_DE_DADOS) ---
    if (sheetHistorico.getLastColumn() === 0) {
      sheetHistorico.appendRow(["TIMESTAMP", "NOME", "DATA"]);
      sheetHistorico.getRange(1, 1, 1, 3).setFontWeight("bold");
    }
    
    let headersHist = sheetHistorico.getRange(1, 1, 1, Math.max(sheetHistorico.getLastColumn(), 1)).getValues()[0];
    
    // Verifica se há novos produtos e cria colunas no cabeçalho do histórico
    Object.keys(data).forEach(key => {
      if (headersHist.indexOf(key.toUpperCase()) === -1 && key !== "timestamp") {
        sheetHistorico.getRange(1, sheetHistorico.getLastColumn() + 1).setValue(key.toUpperCase()).setFontWeight("bold");
        headersHist.push(key.toUpperCase());
      }
    });

    // Monta a linha para o histórico convertendo texto em número onde necessário
    const rowHist = headersHist.map(h => {
      if (h === "TIMESTAMP") return new Date().toLocaleString('pt-BR');
      const val = data[Object.keys(data).find(k => k.toUpperCase() === h)];
      
      // Se for coluna de produto, garante que seja gravado como número para somas no Sheets
      if (h !== "NOME" && h !== "DATA" && val) {
        return parseFloat(val.toString().replace(',', '.')) || 0;
      }
      return val || "";
    });
    sheetHistorico.appendRow(rowHist);


    // --- PARTE 2: LÓGICA DE SOMA (ORGANIZAÇÃO_DE_DADOS) ---
    // Coluna A = Nome do Produto | Colunas B, C, D... = Nomes dos Produtores
    
    const nomeProdutor = data.nome;
    const ultimaColCons = Math.max(sheetConsolidado.getLastColumn(), 1);
    let headersCons = sheetConsolidado.getRange(1, 1, 1, ultimaColCons).getValues()[0];
    
    // 1. Localiza a coluna do produtor ou cria uma nova se não existir
    let colProdutor = headersCons.indexOf(nomeProdutor) + 1;
    if (colProdutor === 0) {
      colProdutor = ultimaColCons + 1;
      sheetConsolidado.getRange(1, colProdutor).setValue(nomeProdutor).setFontWeight("bold");
    }

    // 2. Itera sobre os dados recebidos para somar as quantidades
    Object.keys(data).forEach(key => {
      if (key !== "nome" && key !== "data" && key !== "timestamp") {
        const nomeProd = key.replace(/_/g, " ").toUpperCase();
        const qtdNova = parseFloat(data[key].toString().replace(',', '.')) || 0;

        if (qtdNova > 0) {
          let ultimaLinhaCons = Math.max(sheetConsolidado.getLastRow(), 1);
          let listaProdsCons = sheetConsolidado.getRange(1, 1, ultimaLinhaCons, 1).getValues().map(r => r[0].toString().toUpperCase());
          let linhaProd = listaProdsCons.indexOf(nomeProd) + 1;

          // Se o produto não estiver na Coluna A, adiciona ele em uma nova linha
          if (linhaProd === 0) {
            linhaProd = ultimaLinhaCons + 1;
            sheetConsolidado.getRange(linhaProd, 1).setValue(nomeProd).setFontWeight("bold");
          }

          // RECUPERA VALOR ATUAL E SOMA O NOVO
          const celula = sheetConsolidado.getRange(linhaProd, colProdutor);
          const valorAnterior = parseFloat(celula.getValue()) || 0;
          celula.setValue(valorAnterior + qtdNova);
        }
      }
    });

    lock.releaseLock();
    return ContentService.createTextOutput(JSON.stringify({
      "status": "Sucesso",
      "message": "Dados registrados e somados em ORGANIZAÇÃO_DE_DADOS."
    })).setMimeType(ContentService.MimeType.JSON);

  } catch (err) {
    if (lock.hasLock()) lock.releaseLock();
    return ContentService.createTextOutput(JSON.stringify({
      "status": "Erro", 
      "message": err.message
    })).setMimeType(ContentService.MimeType.JSON);
  }
}
