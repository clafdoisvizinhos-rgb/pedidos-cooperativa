/**
 * Recebe os dados do formulário e organiza em duas frentes:
 * 1. Histórico: Guarda uma linha nova com data (Histórico Completo).
 * 2. Consolidação: Soma as quantidades numa folha de resumo (Total Mensal).
 * Nome da aba de consolidação: ORGANIZAÇÃO_DE_DADOS
 */
function doPost(e) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  // Aba 1: Histórico (Onde cada entrega é uma linha)
  const sheetHistorico = ss.getSheets()[0]; 
  
  // Nome específico solicitado pelo utilizador
  const NOME_ABA_CONSOLIDADO = "ORGANIZAÇÃO_DE_DADOS";
  
  // Aba 2: Organização (Onde os dados são somados)
  let sheetConsolidado = ss.getSheetByName(NOME_ABA_CONSOLIDADO);
  
  // Se a aba não existir, o script cria-a automaticamente
  if (!sheetConsolidado) {
    sheetConsolidado = ss.insertSheet(NOME_ABA_CONSOLIDADO);
  }

  const data = e.parameter;
  // Garante que o nome do produtor fica em MAIÚSCULAS
  if (data.nome) data.nome = data.nome.toUpperCase();
  
  const lock = LockService.getScriptLock();
  
  try {
    // Tenta obter o bloqueio por até 30 segundos para evitar erros em envios simultâneos
    lock.waitLock(30000);

    // --- PARTE 1: GUARDAR NO HISTÓRICO (LÓGICA PADRÃO) ---
    if (sheetHistorico.getLastColumn() === 0) {
      sheetHistorico.appendRow(["TIMESTAMP", "NOME", "DATA"]);
      sheetHistorico.getRange(1, 1, 1, 3).setFontWeight("bold");
    }
    
    let headersHist = sheetHistorico.getRange(1, 1, 1, Math.max(sheetHistorico.getLastColumn(), 1)).getValues()[0];
    
    Object.keys(data).forEach(key => {
      if (headersHist.indexOf(key.toUpperCase()) === -1 && key !== "timestamp") {
        sheetHistorico.getRange(1, sheetHistorico.getLastColumn() + 1).setValue(key.toUpperCase()).setFontWeight("bold");
        headersHist.push(key.toUpperCase());
      }
    });

    const rowHist = headersHist.map(h => {
      if (h === "TIMESTAMP") return new Date().toLocaleString('pt-BR');
      const val = data[Object.keys(data).find(k => k.toUpperCase() === h)];
      // Converte quantidades para números para permitir somas futuras
      if (h !== "NOME" && h !== "DATA" && val) {
        return parseFloat(val.toString().replace(',', '.')) || 0;
      }
      return val || "";
    });
    sheetHistorico.appendRow(rowHist);


    // --- PARTE 2: SOMAR NA PLANILHA DE ORGANIZAÇÃO (CONSOLIDAÇÃO) ---
    // Estrutura: Coluna A = Produtos | Colunas B, C, D... = Produtores
    
    const nomeProdutor = data.nome;
    const ultimaColCons = Math.max(sheetConsolidado.getLastColumn(), 1);
    let headersCons = sheetConsolidado.getRange(1, 1, 1, ultimaColCons).getValues()[0];
    
    // 1. Localizar ou criar coluna do Produtor no cabeçalho
    let colProdutor = headersCons.indexOf(nomeProdutor) + 1;
    if (colProdutor === 0) {
      colProdutor = ultimaColCons + 1;
      sheetConsolidado.getRange(1, colProdutor).setValue(nomeProdutor).setFontWeight("bold");
    }

    // 2. Lançar produtos somando os valores existentes
    Object.keys(data).forEach(key => {
      // Ignora campos que não são produtos
      if (key !== "nome" && key !== "data" && key !== "timestamp") {
        const nomeProd = key.replace(/_/g, " ").toUpperCase();
        const qtdNova = parseFloat(data[key].toString().replace(',', '.')) || 0;

        if (qtdNova > 0) {
          let ultimaLinhaCons = Math.max(sheetConsolidado.getLastRow(), 1);
          let listaProdsCons = sheetConsolidado.getRange(1, 1, ultimaLinhaCons, 1).getValues().map(r => r[0].toString().toUpperCase());
          let linhaProd = listaProdsCons.indexOf(nomeProd) + 1;

          // Se o produto não existe na lista lateral (Coluna A), adiciona-o
          if (linhaProd === 0) {
            linhaProd = ultimaLinhaCons + 1;
            sheetConsolidado.getRange(linhaProd, 1).setValue(nomeProd).setFontWeight("bold");
          }

          // Realiza a soma do valor atual com o novo valor enviado
          const celula = sheetConsolidado.getRange(linhaProd, colProdutor);
          const valorAtual = parseFloat(celula.getValue()) || 0;
          
          // Define o novo valor somado
          celula.setValue(valorAtual + qtdNova);
        }
      }
    });

    lock.releaseLock();
    return ContentService.createTextOutput(JSON.stringify({
      "status": "Sucesso",
      "message": "Dados processados e SOMADOS em ORGANIZAÇÃO_DE_DADOS"
    })).setMimeType(ContentService.MimeType.JSON);

  } catch (err) {
    if (lock.hasLock()) lock.releaseLock();
    return ContentService.createTextOutput(JSON.stringify({
      "status": "Erro", 
      "message": err.message
    })).setMimeType(ContentService.MimeType.JSON);
  }
}
